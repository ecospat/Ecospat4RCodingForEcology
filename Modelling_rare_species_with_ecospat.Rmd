---
title: "Modelling Rare Species"
author: "Flavien Collart"
date: '2023-13-11'
output:
  pdf_document: default
  word_document: default
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# a. Modeling rare species

In this section, we will use the ecospat package to employ the method called "ensemble of small models (ESM)", which was developed by [@lomba2010; @breiner2015; @breiner2018], which is particularly suitable for rare species. One of the major problems to model rare species is that the number of occurrences is usually scarce. Although some studies reported that species could be accurately modeled with very low sample size (e.g. 3 occurrences in @vanproosdij2015), sample size is problematic for the modeling procedure, with the risk of overfitting models when the number of occurrences is low compared to the number of predictors. In general, authors are limiting the number of predictors that are put in a model using the rule of thumb that not more than one predictor term should be used per 10 occurrences. To avoid this limitation, ESMs compute bivariate models and then combine all possible bivariate models into an ensemble. By averaging simple small models to an ensemble, ESMs avoid overfitting without losing explanatory power through reducing the number of predictor variables, and were shown to perform significantly better than standard SDMs with species having a low number of occurrences @breiner2015. For this section, we will be focusing on modeling the ecological niche of *Veronica alpina* in the Western Swiss Alps.

## i. Pre-Modeling

The ESM functions of the ecospat package relies on biomod2. We thus need to first format our data by using the function 'BIOMOD_FormatingData', where species occurrences and associated coordinates, the environmental conditions and the name of the species of interest are given. In this example we use presence-absence data for 300 plots, where *Veronica alpina* is present in 12 locations. We also have 5 environmental predictors in our study area. These variables are the growing degree days (with a 0°C threshold), moisture index over the growing season (average values for June to August in mm day-1), the annual sum of radiation (in kJ m-2 year-1), Slope (in degrees), and the topographic position .

```{r , results='hide', message=F, warning=F}
# Load the packages
library(ecospat)
library(biomod2)
library(terra)
library(viridis)
```

```{r, message=F, warning=F}
set.seed(123)
data("ecospat.testData")

# coordinates of the plots
xy <- ecospat.testData[,2:3]
# species presences and absences
sp_occ <- ecospat.testData$Veronica_alpina
sum(sp_occ) ## Number of occurrences

# environmental data
env <- rast(system.file("extdata/ecospat.testEnv.tif", package="ecospat"))

```

```{r, results='hide',message=F, warning=F}
# Formatting the data with the BIOMOD_FormatingData() function from the package biomod2
myBiomodData <- biomod2::BIOMOD_FormatingData(resp.var = 
                                                as.numeric(sp_occ),
                                              expl.var = env,
                                              resp.xy = xy,
                                              resp.name = 
                                                "Veronica.Alpina",
                                              filter.raster = TRUE)
```

## ii. Core-Modeling

The function *ecospat.ESM.Modeling* is used to model the ecological niche of the species by generating bivariate models.

The argument *data* is for the formatted dataset object generated by BIOMOD_FormatingData.

The desired algorithms can be provided in the argument *models*. Model parameters can be adapted via the argument *models.options* by giving the object from the function BIOMOD_ModellingOptions() of the biomod2 package. As in the package biomod2, ESM can fit 12 different algorithms: Generalized Linear Model ('GLM'), Gradient Boosted Machine ('GBM'), eXtreme Gradient Boosting Training (XGBOOST), Generalized Additive Models ('GAM'), 'CTA', Artificial Neural Network ('ANN'), 'SRE', 'FDA', 'MARS', 'RF', Maximum entropy ('MAXENT', using the java software or 'MAXNET' from the maxnet package). Tuning to obtain the optimal parameters for the model can be realized with the argument *tune*. *Prevalence* can be set to build a "weighted response". If NULL, each observation (presence or absence) will have the same weight. You can also give a specific weight to observations via the argument *Yweights*.

To evaluate the models, the function performs a repeated split-sampling cross-validation using the arguments *DataSplit* and *NbRunEval*. *DataSplit* corresponds to the percentage of observations used to calibrate the models. *NbRunEval* indicates the number of times the split-sampling procedure is replicated. The function also allows user-defined cross-validations by giving a logical matrix in the argument *DataSplitTable*, where each row corrends to an observation and each column corresponds to a run. A value TRUE means that an observation will be used for model calibration while a FALSE is for model evaluation.

*weighting.score* corresponds to the evaluation metric that will be used to weight single bivariate models in the final ensemble model. The available evaluation metrics are: 'AUC', 'SomersD' (2xAUC-1), 'Kappa', 'TSS' or 'Boyce'.

*which.biva* allows to split the bivariate model procedure in several parts. For example, if which.biva is 1:3, only the three first variable combinations will be modeled. This allows to run different bivariate splits on different computers. However, it is better not to use this option if all models are run on a single computer. If you do so, make sure to give each of your modeling subset a unique *modeling.id.* and avoid space characters.

Parallel computing can be enabled with the argument *parallel*

```{r, include=FALSE}
my.ESM <-ecospat.ESM.Modeling(data = myBiomodData,
                              NbRunEval = 3, 
                              DataSplit = 70, 
                              DataSplitTable = NULL, 
                              Prevalence = 0.5,
                              weighting.score = "SomersD", 
                              models = "GLM", 
                              tune = FALSE,
                              modeling.id = as.character(
                                format(Sys.time(), "%s")), 
                              models.options = NULL, 
                              which.biva = NULL, 
                              parallel = FALSE, 
                              cleanup = FALSE,
                              Yweights = NULL)
```

The following step is to combine all the bivariate models into an ensemble. To so, we can use the function *ecospat.ESM.EnsembleModeling* which will need the object returned by *ecospat.ESM.Modeling*, the evaluation metric used to weight the bivariate models (*weighting.score*) and a *threshold* to remove poor performing models. The argument *models* allows to select one or several algorithms to realize the ensemble.

```{r}
my.ESM.EF <- ecospat.ESM.EnsembleModeling(ESM.modeling.output = my.ESM, 
                                          weighting.score = "SomersD", 
                                          threshold = 0, 
                                          models = NULL)
```

ESM performances resulted from the cross-validations can be observed in the object returned by *ecospat.ESM.EnsembleModeling*.

```{r, results='hide'}
t(my.ESM.EF$ESM.evaluations)
```

```{r, echo = F, results='asis',warning=FALSE,message=FALSE}
library(knitr)
kable(t(my.ESM.EF$ESM.evaluations), caption = "ESM performances based on a mean or standard deviations across bivariate model performances of a same run", digits = 3, longtable = TRUE)

```

However, because a minimum sample size is needed to evaluate models (see [@jiménez-valverde2020]), it is recommended to evaluate ESMs using the pooling evaluation ([@collart2023]). The function *ecospat.ESM.EnsembleEvaluation* uses this approach, which consists of pooling the suitability values predicted with the hold-out data (evaluation dataset) across replicates. As the same observation(presence or absence or background point) is presumably sampled in several replicates, the suitability values for each data point are consequently averaged across replicates where they were sampled. This procedure generates a series of independent suitability values with a size approximately equal to that of the number of observations (the number of suitability values might be slightly lower than the number of original observations as some data points may not be sampled by chance in any of the n replicates). This function can compute several metrics, which can be selected with the argument *metrics*. If needed, *EachSmallModels* allows to evaluate each bivariate models via the pooling evaluation

```{r, results='hide'}
my.ESM.EF.eval <- ecospat.ESM.EnsembleEvaluation(
                                ESM.modeling.output = my.ESM,
                                ESM.EnsembleModeling.output = 
                                  my.ESM.EF,
                                metrics = c("SomersD","AUC","
                                           MaxTSS","MaxKappa",
                                           "Boyce"), 
                                EachSmallModels = FALSE)

## Evaluation dataset obtained by the pooling evaluation
pred.test <- as.data.frame(my.ESM.EF.eval$ESM.fit)

## Evaluation scores of the ESM based on the pooling evaluation
my.ESM.EF.eval$ESM.evaluations
```

```{r, echo = F, results='asis',warning=FALSE,message=FALSE}
library(knitr)
kable(my.ESM.EF.eval$ESM.evaluations, caption = "ESM performances based on the pooling evaluation", digits = 3)
```

Ecospat package also has numerous functions to compute model performances on your own. By providing model predictions and species observation.

For example, the Boyce index which only requires presences can be calculated with the function *ecospat.boyce*. The argument *obs* should contain the model prediction for the presences while *fit* should contain the predictions of background points. Correlation measurement can be changed via the argument *method*

```{r}
boyce.index <- ecospat.boyce(fit = pred.test$Fit_GLM, 
                             obs = pred.test$Fit_GLM[pred.test$resp==1], 
                             PEplot = FALSE,
                             method = "spearman")
boyce.index$cor
```

MaxTSS and MaxKappa can be estimated via the functions *ecospat.max.tss* and *ecospat.max.kappa* and the variations of TSS and Kappa metric on a threshold can be done with *ecospat.plot.tss* and *ecospat.plot.kappa*

```{r}
MaxTSS <- ecospat.max.tss(Pred = pred.test$Fit_GLM, 
                          Sp.occ = pred.test$resp)
MaxTSS$max.TSS

ecospat.plot.tss(Pred = pred.test$Fit_GLM, 
                 Sp.occ = pred.test$resp)

MaxKappa <- ecospat.max.kappa(Pred = pred.test$Fit_GLM, 
                              Sp.occ = pred.test$resp)
MaxKappa$max.Kappa

ecospat.plot.kappa(Pred = pred.test$Fit_GLM, 
                   Sp.occ = pred.test$resp)
```

Model performances can also be checked by observing species response curves to each environmental predictors. To do so, The function *ecospat.ESM.responsePlot* can be used. This function is an adaptation of the Evaluation Strip method proposed by @elith2005 and needs the objects returned by *ecospat.ESM.Modeling* and *ecospat.ESM.EnsembleModeling*. The statistic used to keep constant the other predictor while generated the response curve for a predictor can be changed via the argument *fixed.var.metric*

```{r, message=F, warning=F}
response.plots <- ecospat.ESM.responsePlot(ESM.EnsembleModeling.output = 
                                             my.ESM.EF,
                                          ESM.modeling.output = my.ESM,
                                          fixed.var.metric = 'median')
```

To check the contribution of each variable, you can use the function *ecospat.ESM.VarContrib*. This function computes the ratio between sum of weights of bivariate models where a focal variable was used and sum of weights of bivariate models where the focal variable was not used. The ratio is corrected for the number of models with or without the focal variable. This ratio gives an indication on the proportional contribution of the variable in the final ensemble model. A value of higher than 1 indicates that the focal variable has a higher contribution than average. For the ensemble model, a weighted mean is applied among model algorithms.

```{r, warning=F,message=F,results=F}
var.contrib <- ecospat.ESM.VarContrib(ESM.modeling.output = my.ESM,
                                      ESM_EF.output = my.ESM.EF)
var.contrib
```

```{r, echo = F, results='asis',warning=FALSE,message=FALSE}
library(knitr)
kable(var.contrib, caption = "Variable contributions to ESMs", digits = 3)
```

After checking the model performances and the response curves, models can be projected using two functions: *ecospat.ESM.Projection* which projects each bivariate model and *ecospat.ESM.EnsembleProjection* which generates the ensemble of these bivariate models. *new.env* argument allows to project models onto a new data.frame, *SpatRaster* of ecological values while *name.env* allows to give a name to the projection. Parallel computing can be enabled with the argument *parallel*

```{r, results='hide', message=FALSE,warning=FALSE}

### Projection of simple bivariate models into new space 
my.ESM.proj.current <- ecospat.ESM.Projection(ESM.modeling.output = my.ESM,
                                              new.env = env,
                                              name.env = "currentTime",
                                              parallel = FALSE,
                                              cleanup = FALSE)

### Projection of calibrated ESMs into new space 
my.ESM.EF.proj.current <- ecospat.ESM.EnsembleProjection(
                                                  ESM.prediction.output = 
                                                    my.ESM.proj.current,
                                                  ESM.EnsembleModeling.output =
                                                    my.ESM.EF,
                                                  chosen.models = "all")
```

```{r}
## projected ESM of Veronica alpina at present time
plot(my.ESM.EF.proj.current, 
     col = rev(viridis::viridis(50)))
points(xy[sp_occ==1,],
       col = "black")

```

## iii. Post-modeling

ESM projections can be afterwards binarized. To binarize these maps, diverse thresholds can be computed via the function *ecospat.ESM.threshold*. This function also provides evaluation scores for the full model (thus, evaluating the fit of the model but not the transferability).

```{r,results="hide"}
Thr <- ecospat.ESM.threshold(ESM.EnsembleModeling.output = my.ESM.EF,
                             PEplot = FALSE)
t(Thr)
```

```{r, echo = F, results='asis',warning=FALSE,message=FALSE}
library(knitr)
obj <- t(Thr[,-1])
colnames(obj) = Thr[1,1]
kable(obj, caption = "Various threshold and fit performances of ESM", digits = 3, longtable = TRUE)
```

Model projections can be afterwards binarized with the function *ecospat.binary.model* which need in the arguments *Pred*, a spatial grid and *Threshold*, the value of the threshold.

```{r}
### Binarization of the projected ESM based on the threshold maximizing the TSS                                     
my.ESM.EF.proj.current.bin <- ecospat.binary.model(Pred = my.ESM.EF.proj.current,
                                                   Threshold = (Thr$TSS.th)*1000)
plot(my.ESM.EF.proj.current.bin)
```

After binarizing maps, one could quantify the species range size or the occupied patches from ESM maps and IUCN criteria. In the ecospat package, the function *ecospat.rangesize* and *ecospat.occupied.patch* are made for these purposes.

More precisely, *ecospat.rangesize* allows quantifying Area of Occupancy AOO and the Extent of Occurrence EOO. Numerous parameters are available and are describe when running in R ?ecospat.rangesize

```{r, warning=FALSE}
rangesize <- ecospat.rangesize(my.ESM.EF.proj.current.bin,
                               xy = xy[sp_occ==1,],
                               AOO.circles = TRUE,
                               lonlat = FALSE)

plot(my.ESM.EF.proj.current.bin,legend = FALSE, 
     main = "IUCN criteria")
plot(rangesize$RangeObjects$AOO,
     add = TRUE, 
     col = "red",
     legend = FALSE)
plot(rangesize$RangeObjects$EOO@polygons,
     add = TRUE, 
     border = "red", 
     lwd = 2)
```

*ecospat.occupied.patch* quantified the number of patches where species occupied based on species distribution predictions, species occurrences and a buffer value (in meter) around species occurrences.

```{r}
ocp  <- ecospat.occupied.patch(my.ESM.EF.proj.current.bin,
                               xy[sp_occ==1,],
                               buffer = 500)
plot(ocp,
     col = viridis::viridis(50)) ## occupied patches: colored areas
points(xy[sp_occ==1,],col = "red",
       cex = 0.5,
       pch = 19)
```
